<div class="hill-climbing-container">
  <section class="intro-section">
    <h1>Hill Climbing</h1>
    <p>
      El Hill Climbing es una técnica de optimización matemática que pertenece a la familia de algoritmos de búsqueda
      local. Se trata de un algoritmo iterativo que parte de una solución arbitraria para un problema y luego intenta
      encontrar una mejor mediante un cambio incremental. Si el cambio produce una mejor solución, se realiza otro
      cambio incremental en la nueva solución, y así sucesivamente hasta que no se encuentren más mejoras.
    </p>
  </section>

  <h2>¿Como funciona Hill Climbing?</h2>
  <section class="algorithm-section">
    <ol>
      <li>Comienza con una solución aleatoria.</li>
      <li>Evalúa la solución actual.</li>
      <li>Encuentra soluciones vecinas.</li>
      <li>Evalúa cada solución vecina.</li>
      <li>Si una solución vecina es mejor que la actual, muévete a esa solución vecina.</li>
      <li>Repite los pasos 2 a 5 hasta que no encuentres soluciones vecinas mejores.</li>
    </ol>
    <p>
      El método de ascenso de pendientes es fácil de implementar y funciona bien en muchos problemas, pero puede
      estancarse en óptimos locales en lugar de encontrar el óptimo global.
    </p>
  </section>

  <section class="code-section">
    <h2>Implementación en Python</h2>
    <p>Aquí hay una implementación básica de la optimización de la función objetivo usando NumPy y pandas:</p>
    <div class="code-container">
      <pre><code [innerText]="codeSnippet">

      </code></pre>
    </div>
  </section>

  <section class="applications-section">
    <h2>Applicaciones del Hill Climbing</h2>
    <ul>
      <li>Machine Learning: Encontrar parámetros óptimos de modelos</li>
      <li>Robotica: Planificación de rutas y control de movimiento</li>
      <li>Programación de tareas: Problemas de asignación de recursos</li>
      <li>Diseño de red: Optimización de topologías de redes</li>
      <li>Juegos de IA: Decisión en juegos</li>
    </ul>
  </section>

  <section class="limitations-section">
    <h2>Limitaciones y variaciones</h2>
    <p>
      Aunque el hill Climbing es sencillo, tiene algunas limitaciones:
    </p>
    <ul>
      <li><strong>Óptimos Locales:</strong> Puede quedarse atrapado en óptimos locales</li>
      <li><strong>Mesetas:</strong> Tiene dificultades con áreas planas donde los vecinos tienen valores iguales</li>
      <li><strong>Crestas:</strong> Puede oscilar en paisajes tipo cresta</li>
    </ul>
    <p> Las variaciones para abordar estas limitaciones incluyen: </p>
    <ul>
      <li><strong>Ascenso de Colina Estocástico:</strong> Selecciona aleatoriamente entre los movimientos ascendentes
      </li>
      <li><strong>Ascenso de Colina de Primera Opción:</strong> Selecciona el primer vecino mejor</li>
      <li><strong>Ascenso de Colina con Reinicio Aleatorio:</strong> Realiza múltiples ejecuciones de ascenso de colina
        desde puntos de inicio aleatorios</li>
      <li><strong>Recocido Simulado:</strong> Permite movimientos ocasionales descendentes para escapar de los óptimos
        locales</li>
    </ul>
  </section>

  <section class="infographic-section">
    <h2>Infografia relacionada a Algoritmos Geneticos</h2>
    <div class="infographic-placeholder">
      <!-- Placeholder for infographic -->
      <img src="/assets/algGenetico.png" alt="Infografía de Hill Climbing">
    </div>
  </section>

  <section class="code-section">
    <h2>Implementación en Python de un Algoritmo Genetico</h2>
    <p>Aquí hay una implementación básica de la optimización de la función objetivo usando Python y DEAP:</p>
    <div class="code-container">
      <pre><code [innerText]="codeSnippet2">

      </code></pre>
    </div>
  </section>

</div>